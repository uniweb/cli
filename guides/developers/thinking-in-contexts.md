# Thinking in Contexts

When you build components for a Uniweb foundation, you'll notice something is missing: color decisions. There's no `bg-white` for light sections, no `text-white` for dark ones, no theme map that tries to cover every combination. And that's the point.

This guide explains how CCA's semantic theming works, what it gives you, and the rare cases where you need to step outside it.

---

## The Old Way

Here's a pattern you've probably written before — or inherited from a template:

```jsx
const themes = {
  light: { section: 'bg-white', title: 'text-gray-900', text: 'text-gray-600' },
  dark: { section: 'bg-gray-900', title: 'text-white', text: 'text-gray-300' },
  gray: { section: 'bg-gray-50', title: 'text-gray-900', text: 'text-gray-600' },
}
const t = themes[params.theme] || themes.light
```

Every component duplicates this. Every component makes the same color assumptions. And when you want to ship this foundation to a different organization — one with green branding instead of blue, or a warm color palette instead of a cool one — you're editing every component.

This is the problem CCA solves.

---

## How Contexts Work

In CCA, sections have a **context** — `light`, `medium`, or `dark`. The content author sets it in frontmatter:

```yaml
---
type: Features
theme: medium
---
```

The runtime wraps your component in a `<section class="context-medium">`. Inside that wrapper, CSS variables resolve to appropriate values:

| Token | context-light | context-medium | context-dark |
|-------|---------------|----------------|--------------|
| `--heading` | near-black | near-black | white |
| `--text` | dark gray | dark gray | light gray |
| `--text-muted` | medium gray | medium gray | lighter gray |
| `--bg` | white | light gray | dark gray |
| `--bg-subtle` | off-white | slightly darker | slightly lighter |
| `--border` | light line | slightly darker line | dark line |
| `--link` | primary-600 | primary-600 | primary-400 |

Your component never checks which context it's in. It uses semantic classes and they resolve automatically:

```jsx
export function Features({ content, params }) {
  const { title, items } = content

  return (
    <div className="py-16 px-6">
      <h2 className="text-3xl font-bold text-heading">{title}</h2>
      <div className="grid md:grid-cols-3 gap-8">
        {items.map((item, i) => (
          <div key={i} className="p-6 bg-surface-subtle border border-edge-muted rounded-xl">
            <h3 className="text-xl font-semibold text-heading">{item.title}</h3>
            <p className="text-muted">{item.paragraphs?.[0]}</p>
          </div>
        ))}
      </div>
    </div>
  )
}
```

That's the entire component. No theme map. No conditional logic. One set of classes that works everywhere.

---

## Connecting Tokens to Tailwind

The semantic tokens are CSS variables generated by the build system. To use them as Tailwind classes, your foundation maps them in `styles.css` using `@theme inline`:

```css
@theme inline {
  --color-heading: var(--heading);
  --color-body: var(--text);
  --color-muted: var(--text-muted);
  --color-subtle: var(--text-subtle);

  --color-surface: var(--bg);
  --color-surface-subtle: var(--bg-subtle);
  --color-surface-muted: var(--bg-muted);

  --color-edge: var(--border);
  --color-edge-muted: var(--border-muted);

  --color-link: var(--link);
  --color-link-hover: var(--link-hover);

  --color-btn-primary: var(--btn-primary-bg);
  --color-btn-primary-text: var(--btn-primary-text);
  --color-btn-primary-hover: var(--btn-primary-hover);
}
```

Now `text-heading` is a real Tailwind class. So are `bg-surface-subtle`, `border-edge-muted`, `text-btn-primary-text`, and all the rest. You get Tailwind's ergonomics — responsive prefixes, hover states, arbitrary values — backed by tokens that adapt to any context.

The naming is yours to choose. These names (`surface`, `edge`, `heading`, `muted`) are conventions, not requirements. What matters is that they map to semantic CSS variables, not to specific colors.

---

## The Brand Palette

Beyond semantic tokens, the build also generates color palettes from `theme.yml`. Four color roles are supported:

```yaml
colors:
  primary: "#047857"      # Main brand color (buttons, links, accents)
  secondary: "#78716c"    # Supporting color
  accent: "#d97706"       # Highlight color (badges, callouts, special emphasis)
  neutral: "#57534e"      # Drives all context tokens (bg, text, borders)
```

Each color produces eleven shades: `--primary-50` through `--primary-950`, and the same for secondary, accent, and neutral. You map them to Tailwind in `styles.css`:

```css
@theme inline {
  --color-primary-50: var(--primary-50);
  --color-primary-100: var(--primary-100);
  /* ... through 950 ... */
  --color-primary: var(--primary-500);

  --color-accent-50: var(--accent-50);
  /* ... same pattern ... */
  --color-accent: var(--accent-500);
}
```

Use palette colors for intentional brand touches — icon containers, tag badges, active indicators — where you want a specific shade regardless of context:

```jsx
{/* Brand accent — always primary, in any context */}
<div className="bg-primary-100/50 text-primary-600 rounded-xl">
  <Icon name={icon} />
</div>

{/* Tags */}
<span className="bg-primary-50 text-primary-700 rounded px-2 py-1">
  {tag}
</span>

{/* Special callout — using accent color */}
<span className="bg-accent-100 text-accent-700 rounded px-2 py-1">
  New
</span>
```

The palettes adapt when the site changes its colors. A conservation site with green primary and amber accent, and a fintech site with blue primary and violet accent, both get correct, harmonious shades — without touching component code.

**Primary vs accent:** Primary is your workhorse brand color — buttons, links, active states. Accent is for moments that need to stand out *from* the brand — callouts, highlights, "new" badges. Not every foundation needs to use accent, but the palette is there if you map it.

---

## What the Site Controls

The foundation declares *structure*. The site declares *identity*. This separation is what makes foundations portable.

The site's `theme.yml` controls:

```yaml
colors:
  primary: "#047857"      # Brand color → generates full palette
  secondary: "#78716c"    # Supporting color
  accent: "#d97706"       # Highlight color
  neutral: "#57534e"      # Drives all context tokens (bg, text, borders)

fonts:
  import:
    - url: "https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Inter:wght@400;500;600;700&display=swap"
  heading: "DM Serif Display, Georgia, serif"
  body: "Inter, system-ui, sans-serif"
```

The `neutral` color is quietly powerful. It's the base for every context token — the grays in your backgrounds, text, and borders. A cool neutral (zinc) gives a tech feel. A warm neutral (stone) gives an organic feel. The foundation doesn't know or care which one the site chose.

Content authors control *which context* each section uses, in frontmatter:

```yaml
---
type: CTA
theme: dark
background:
  color: var(--primary-600)
---
```

This gives the section a green background with light text. The component just renders `text-heading` and `bg-btn-primary` — it doesn't know the background is green, or that the text is white. It knows it's in a dark context, and the tokens handle the rest.

---

## You Always Need a Site

If you're coming from other frameworks, you might expect to develop a component library in isolation — render components in a storybook, pass them props, see what they look like. In CCA, there's one extra requirement: your components use semantic tokens like `text-heading` and `bg-surface-subtle`, and those tokens need a site to activate the theming pipeline.

The chain looks like this:

```
site/theme.yml  →  build generates palette + context CSS  →  tokens resolve  →  your components have colors
```

No site, no `theme.yml`, no colors. Your `text-heading` class targets `var(--heading)`, which is set by `.context-light { --heading: var(--neutral-900) }`, which depends on `--neutral-900` existing, which comes from the palette generated from `theme.yml`'s `neutral` color. Remove any link in that chain and you're styling against undefined variables.

This is why even the simplest Uniweb project starts with two packages — a site and a foundation:

```
my-project/
├── site/               ← activates theming, holds test content
│   ├── site.yml
│   ├── theme.yml       ← this is what makes your tokens work
│   └── pages/
│       └── home/
│           └── hero.md
└── foundation/
    └── src/
        └── sections/
            └── Hero/
                ├── meta.js
                └── Hero.jsx
```

The site might be purely a testbed — throwaway content, a quick `theme.yml` with a single primary color. That's fine. Its job during development is to give the build system something to generate CSS from. Later, a real site with real content and real branding will use your foundation, and every semantic token will resolve to *that* site's colors instead.

Think of it this way: you're not building components that *have* colors. You're building components that *receive* colors from whatever site adopts them. The development site is how you see that contract in action.

If you want to verify that your components truly adapt, try changing the primary color in `theme.yml` and rebuilding. Everything branded — buttons, links, accents, tag badges — should shift to the new color without touching any component code. If something doesn't change, you've found a hardcoded color that should be a token.

---

## Components Don't Render `<section>`

One detail that's easy to miss: your component's root element should be a `<div>`, not a `<section>`. The runtime's BlockRenderer already wraps your component:

```html
<!-- BlockRenderer output -->
<section class="context-dark" id="section-cta">
  <!-- Your component renders here -->
  <div class="py-16 px-6">
    <h2 class="text-heading">...</h2>
  </div>
</section>
```

If your component also renders `<section>`, you get nested sections — semantically wrong and potentially competing for background/padding control. Render a `<div>`, a `<footer>`, an `<article>` — whatever is semantically appropriate for your content, but not `<section>`.

---

## When to Break the Rules

Most components should use semantic tokens exclusively. But two patterns legitimately need hardcoded colors.

### Floating overlays: the Header

The Header doesn't live *inside* a context — it floats *across* them. When it's transparent over a dark hero, the text must be white. When the user scrolls and it gets a white background, the text must be dark. When a dropdown opens, the panel is always light regardless of what's behind it.

These are absolute visual requirements, not contextual ones:

```jsx
// Floating header — hardcoded, because it defines its own visual context
const getHeaderStyles = () => {
  if (isFloating && !scrolled && isDarkBackground) {
    return 'bg-transparent text-white'      // absolute: white text over dark hero
  }
  return 'bg-white shadow-sm text-gray-900' // absolute: white bar when scrolled
}

// Dropdown — always its own light panel
<div className="bg-white rounded-lg shadow-lg border border-gray-100">
```

But even in the Header, normal-state nav links can use semantic tokens:

```jsx
// Non-floating nav links — these DO live in a context
return 'text-muted hover:text-body'
```

The principle: use semantic tokens for elements that inherit from their surroundings. Use hardcoded colors for elements that *define* their surroundings.

### Self-contexting components: the Hero gradient

The Hero has a "gradient" variant that renders its own background — a gradient built from palette colors. This gradient creates a dark visual context, so the text inside needs dark-context tokens. But the runtime doesn't know the Hero is going to render a dark gradient — it might have set `context-light` on the wrapper.

The solution is for the Hero to set its own context:

```jsx
const isGradient = variant === 'gradient' && !_hasBackground

return (
  <div className={cn(
    'relative py-20 px-6',
    isGradient && 'bg-gradient-to-br from-primary-700 via-primary-800 to-primary-950 context-dark'
  )}>
    {/* These tokens now resolve for dark context */}
    <h1 className="text-heading">{title}</h1>
    <p className="text-muted">{description}</p>
  </div>
)
```

Adding `context-dark` on the component's own root element overrides the wrapper's context class via CSS proximity. The inner `context-dark` is closer to the text elements, so its token values win.

This is justified, but it's exceptional. Most components should never set their own context — that's the content author's job via `theme:` in frontmatter. The Hero does it because the gradient *is* visual context, and it would be wrong to force content authors to remember "if you set variant to gradient, also set theme to dark."

When the content author *does* set a background (via the `background:` frontmatter), the Hero skips the gradient entirely — `_hasBackground` is true, the engine's Background component handles the visual, and the `theme:` frontmatter controls the context as usual.

---

## The Payoff

After converting a foundation to semantic theming, the typical component goes from ~50 lines to ~30. But the line count isn't the point. The real gains:

**You stop making color decisions.** The hardest part of the old approach wasn't writing the theme map — it was deciding that `text-gray-600` was the right muted color, and that `text-gray-300` was its dark equivalent, and keeping those decisions consistent across twelve components. With semantic tokens, you make that decision once (in the build system), and every component inherits it.

**Foundations become portable.** The same foundation works for a conservation organization (warm greens), a law firm (navy and slate), and a startup (bright violet) — the site's `theme.yml` controls the identity, and every component adapts without modification.

**New contexts work immediately.** If the build system adds a `context-accent` in the future, every semantic-token-using component supports it without changes. The components don't know what contexts exist — they just use tokens that resolve.

**You don't build theme-switching logic.** Content authors set `theme: dark` on any section in frontmatter, and the entire visual context inverts. `background: { color: var(--primary-600) }` brands a section. These controls work without any conditional logic in your component — the tokens handle it.

---

## Quick Reference

| Intent | Class | Token |
|--------|-------|-------|
| Primary heading | `text-heading` | `--heading` |
| Body text | `text-body` | `--text` |
| Secondary text | `text-muted` | `--text-muted` |
| Tertiary/hint text | `text-subtle` | `--text-subtle` |
| Section background | `bg-surface` | `--bg` |
| Card/well background | `bg-surface-subtle` | `--bg-subtle` |
| Hover/zebra background | `bg-surface-muted` | `--bg-muted` |
| Primary border | `border-edge` | `--border` |
| Subtle border | `border-edge-muted` | `--border-muted` |
| Link text | `text-link` | `--link` |
| Link hover | `hover:text-link-hover` | `--link-hover` |
| Primary button bg | `bg-btn-primary` | `--btn-primary-bg` |
| Primary button text | `text-btn-primary-text` | `--btn-primary-text` |
| Primary button hover | `hover:bg-btn-primary-hover` | `--btn-primary-hover` |
| Secondary button bg | `bg-btn-secondary` | `--btn-secondary-bg` |
| Secondary button text | `text-btn-secondary-text` | `--btn-secondary-text` |
| Brand accent (specific shade) | `text-primary-600` | `--primary-600` |
| Brand badge | `bg-primary-100 text-primary-700` | palette shades |
