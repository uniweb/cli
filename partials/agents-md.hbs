# AGENTS.md

Guidance for AI agents working with this Uniweb project.

## Project Structure

```
project/
├── foundation/     # React component library
├── site/           # Content (markdown pages)
└── pnpm-workspace.yaml
```

Multi-site variant uses `foundations/` and `sites/` (plural) folders.

- **Foundation**: React components. Those with `meta.js` are *section types* — selectable by content authors via `type:` in frontmatter. Everything else is ordinary React.
- **Site**: Markdown content + configuration. Each section file references a section type.

## Commands

```bash
pnpm install    # Install dependencies
pnpm dev        # Start dev server
pnpm build      # Build for production
```

## Content Authoring

### Section Format

Each `.md` file is a section. Frontmatter on top, content below:

```markdown
---
type: Hero
theme: dark
---

### Eyebrow Text        ← pretitle (heading before a more important one)

# Main Headline         ← title

## Subtitle             ← subtitle

Description paragraph.

[Call to Action](/link)

![Image](./image.jpg)
```

### Content Shape

The semantic parser extracts markdown into a flat, guaranteed structure. No null checks needed — empty strings/arrays if content is absent:

```js
content = {
  title: '',        // Main heading
  pretitle: '',     // Heading before main title (auto-detected)
  subtitle: '',     // Heading after title
  subtitle2: '',    // Third-level heading
  paragraphs: [],   // Text blocks
  links: [],        // { href, label, role } — standalone links become buttons
  imgs: [],         // { src, alt, role }
  icons: [],        // { library, name, role }
  videos: [],       // Video embeds
  lists: [],        // Bullet/ordered lists
  quotes: [],       // Blockquotes
  data: {},         // From tagged code blocks (```yaml:tagname)
  headings: [],     // Overflow headings after subtitle2
  items: [],        // Each has the same flat structure — from headings after body content
  sequence: [],     // All elements in document order
}
```

**Items** are repeating content groups (cards, features, FAQ entries). Created when a heading appears after body content:

```markdown
# Our Features          ← title

We built this for you.  ← paragraph

### Fast                ← items[0].title
Lightning quick.        ← items[0].paragraphs[0]

### Secure              ← items[1].title
Enterprise-grade.       ← items[1].paragraphs[0]
```

### Icons

Use image syntax with library prefix: `![](lu-house)`. Supported libraries: `lu` (Lucide), `hi2` (Heroicons), `fi` (Feather), `pi` (Phosphor), `tb` (Tabler), `bs` (Bootstrap), `md` (Material), `fa6` (Font Awesome 6), and others. Browse at [react-icons.github.io/react-icons](https://react-icons.github.io/react-icons/).

Custom SVGs: `![Logo](./logo.svg){role=icon}`

### Links and Media Attributes

```markdown
[text](url){target=_blank}              <!-- Open in new tab -->
[text](./file.pdf){download}            <!-- Download -->
![alt](./img.jpg){role=banner}          <!-- Role determines array: imgs, icons, or videos -->
```

Standalone links (alone on a line) become buttons. Inline links stay as text links.

### Structured Data

Tagged code blocks pass structured data via `content.data`:

````markdown
```yaml:form
fields:
  - name: email
    type: email
submitLabel: Send
```
````

Access: `content.data?.form` → `{ fields: [...], submitLabel: "Send" }`

### Section Backgrounds

Set `background` in frontmatter — the runtime renders it automatically:

```yaml
---
type: Hero
theme: dark
background: /images/hero.jpg              # Simple: URL (image or video auto-detected)
---
```

Full syntax supports `image`, `video`, `gradient`, `color` modes plus overlays:

```yaml
background:
  image: { src: /img.jpg, position: center top }
  overlay: { enabled: true, type: dark, opacity: 0.5 }
```

Components that render their own background declare `background: 'self'` in `meta.js`.

### Page Organization

```
site/layout/
├── header.md               # type: Header — rendered on every page
├── footer.md               # type: Footer — rendered on every page
└── left.md                 # type: Sidebar — optional sidebar

site/pages/
└── home/
    ├── page.yml            # title, description, order
    ├── hero.md             # Single section — no prefix needed
    └── (or for multi-section pages:)
    ├── 1-hero.md           # Numeric prefix sets order
    ├── 2-features.md
    └── 3-cta.md
```

Decimals insert between: `2.5-testimonials.md` goes between `2-` and `3-`.

**Ignored files/folders:**
- `README.md` — repo documentation, not site content
- `_*.md` or `_*/` — drafts and private content (e.g., `_drafts/`, `_old-hero.md`)

**page.yml:**
```yaml
title: About Us
description: Learn about our company
order: 2                    # Navigation sort position
pages: [team, history, ...] # Child page order (... = rest). Without ... = strict (hides unlisted)
index: getting-started      # Which child page is the index
```

**site.yml:**
```yaml
index: home                         # Just set the homepage
pages: [home, about, ...]           # Order pages (... = rest, first = homepage)
pages: [home, about]                # Strict: only listed pages in nav
```

Use `pages:` with `...` for ordering, without `...` for strict visibility control. Use `index:` for simple homepage selection.

## Semantic Theming

CCA separates theme from code. Components use **semantic CSS tokens** instead of hardcoded colors. The runtime applies a context class (`context-light`, `context-medium`, `context-dark`) to each section based on `theme:` frontmatter.

```jsx
// ❌ Hardcoded — breaks in dark context, locked to one palette
<h2 className="text-slate-900">...</h2>

// ✅ Semantic — adapts to any context and brand automatically
<h2 className="text-heading">...</h2>
```

**Core tokens** (available as Tailwind classes):

| Token | Purpose |
|-------|---------|
| `text-heading` | Headings |
| `text-body` | Body text |
| `text-muted` | Secondary text |
| `bg-surface` | Section background |
| `bg-surface-subtle` | Slightly offset surface |
| `border-edge` | Borders |
| `border-edge-muted` | Subtle borders |
| `text-link` | Link color |
| `text-on-primary` | Text on primary-colored backgrounds |
| `bg-primary` | Brand primary color |

**Content authors control context** in frontmatter:

```markdown
---
type: Testimonial
theme: dark           ← sets context-dark, all tokens resolve to dark values
---
```

**Site controls the palette** in `theme.yml`. The same foundation looks different across sites because tokens resolve from the site's color configuration, not from component code.

**When to break the rules:** Header/footer components that float over content may need direct color logic (reading the first section's theme). Decorative elements with fixed branding (logos) use literal colors.

## Component Development

### Props Interface

```jsx
function MyComponent({ content, params, block }) {
  const { title, paragraphs, links, items } = content  // Guaranteed shape
  const { theme, columns } = params                     // Defaults from meta.js
  const { website } = useWebsite()                      // Or block.website
}
```

### meta.js Structure

```javascript
export default {
  title: 'Feature Grid',
  description: 'Grid of feature cards with icons',
  category: 'marketing',
  // hidden: true,          // Hide from content authors
  // background: 'self',    // Component renders its own background

  content: {
    title: 'Section heading',
    paragraphs: 'Introduction [0-1]',
    items: 'Feature cards with icon, title, description',
  },

  params: {
    columns: { type: 'number', default: 3 },
    theme: { type: 'select', options: ['light', 'dark'], default: 'light' },
  },

  presets: {
    default: { label: 'Standard', params: { columns: 3 } },
    compact: { label: 'Compact', params: { columns: 4 } },
  },

  // Static capabilities for cross-block coordination
  context: {
    allowTranslucentTop: true,  // Header can overlay this section
  },
}
```

All defaults belong in `meta.js`, not inline in component code.

### @uniweb/kit

**Primitives** (`@uniweb/kit`): `H1`–`H6`, `P`, `Span`, `Text`, `Link`, `Image`, `Icon`, `Media`, `Asset`, `SocialIcon`, `FileLogo`, `cn()`

**Styled** (`@uniweb/kit/styled`): `Section`, `Render`, `SidebarLayout`, `Code`, `Alert`, `Table`, `Details`, `Divider`, `Disclaimer`

**Hooks:**
- `useScrolled(threshold)` → boolean for scroll-based header styling
- `useMobileMenu()` → `{ isOpen, toggle, close }` with auto-close on navigation
- `useAccordion({ multiple, defaultOpen })` → `{ isOpen, toggle }` for expand/collapse
- `useActiveRoute()` → `{ route, isActiveOrAncestor(page) }` for nav highlighting (SSG-safe)
- `useGridLayout(columns, { gap })` → responsive grid class string
- `useTheme(name)` → standardized theme classes

**Utilities:** `cn()` (Tailwind class merge), `filterSocialLinks(links)`, `getSocialPlatform(url)`

### Foundation Organization

```
foundation/src/
├── sections/            # Section types (auto-discovered via meta.js)
│   ├── Hero/
│   │   ├── Hero.jsx     # Entry — or index.jsx, both work
│   │   └── meta.js
│   └── Features/
│       ├── Features.jsx
│       └── meta.js
├── components/          # Your React components (no meta.js, not selectable)
│   ├── ui/              # shadcn-compatible primitives
│   │   └── button.jsx
│   └── Card.jsx
└── styles.css
```

Only folders with `meta.js` in `sections/` (or `components/` for older foundations) become section types. Everything else is ordinary React — organize however you like.

### Website and Page APIs

```jsx
const { website } = useWebsite()

// Navigation
const pages = website.getPageHierarchy({ for: 'header' })  // or 'footer'
// → [{ route, navigableRoute, label, hasContent, children }]

// Locale
website.hasMultipleLocales()
website.getLocales()        // [{ code, label, isDefault }]
website.getActiveLocale()   // 'en'
website.getLocaleUrl('es')
```

### Cross-Block Communication

Components read neighboring blocks for adaptive behavior (e.g., translucent header over hero):

```jsx
const firstBody = block.page.getFirstBodyBlockInfo()
// → { type, theme, context: { allowTranslucentTop }, state }

// context = static (from meta.js), state = dynamic (from useBlockState)
```

### Custom Layouts

Layouts live in `foundation/src/layouts/` and are auto-discovered. Set the default in `foundation.js`:

```js
// foundation/src/foundation.js
export default {
  name: 'My Template',              // Display name (falls back to package.json name)
  description: 'A brief description', // Falls back to package.json description
  defaultLayout: 'DocsLayout',
}
```

```jsx
// foundation/src/layouts/DocsLayout/index.jsx
export default function DocsLayout({ header, body, footer, left, right, params }) {
  return (
    <div className="min-h-screen flex flex-col">
      {header && <header>{header}</header>}
      <div className="flex-1 flex">
        {left && <aside className="w-64">{left}</aside>}
        <main className="flex-1">{body}</main>
        {right && <aside className="w-64">{right}</aside>}
      </div>
      {footer && <footer>{footer}</footer>}
    </div>
  )
}
```

Layout receives pre-rendered areas as props: `header`, `body`, `footer`, `left`, `right` (or any custom area names declared in `meta.js`), plus `params`, `page`, and `website`. Pages select layouts and hide areas in `page.yml`:

```yaml
layout:
  name: MarketingLayout
  hide: [left, right]
```

## Converting Existing Designs

When given a monolithic React file (AI-generated or hand-built), don't port line-by-line. Decompose into CCA architecture:

1. **Name by purpose** — `Institutions` → `Testimonial`, `WorkModes` → `FeatureColumns`. Components render a *kind* of content, not specific content.
2. **Separate content from code** — Hardcoded strings → markdown. Layout/styling stays in JSX. Content authors edit words without touching code.
3. **Use semantic tokens** — Replace `text-slate-900` with `text-heading`, `bg-white` with `bg-surface`. Component works in any context and any brand.
4. **UI components → `components/`** — Buttons, badges, cards go in `src/components/` (no `meta.js` needed).

You don't have to convert everything at once. Each section is independent — one can use hardcoded content while another reads from markdown.

## Tailwind CSS v4

Theme defined in `foundation/src/styles.css`:

```css
@import "tailwindcss";
@source "./sections/**/*.{js,jsx}";
@source "../node_modules/@uniweb/kit/src/**/*.jsx";

@theme {
  --color-primary: #3b82f6;
}
```

Use with: `bg-primary`, `text-primary`, `bg-primary/10`

## Troubleshooting

**"Could not load foundation"** — Check `site/package.json` has `"foundation": "file:../foundation"` (or `"default": "file:../../foundations/default"` for multi-site).

**Component not appearing** — Verify `meta.js` exists and doesn't have `hidden: true`. Rebuild: `cd foundation && pnpm build`.

**Styles not applying** — Verify `@source` in `styles.css` includes your component paths. Check custom colors match `@theme` definitions.

## Further Documentation

Full Uniweb documentation is available at **https://github.com/uniweb/docs** — raw markdown files you can fetch directly.

| Section | Path | Topics |
|---------|------|--------|
| **Getting Started** | `getting-started/` | What is Uniweb, quickstart guide, templates overview |
| **Authoring** | `authoring/` | Writing content, site setup, collections, theming, linking, search, recipes, translations |
| **Development** | `development/` | Building foundations, component patterns, data fetching, custom layouts, i18n, converting existing designs |
| **Reference** | `reference/` | site.yml, page.yml, content structure, meta.js, kit hooks/components, theming tokens, CLI commands, deployment |

**Quick access pattern:** `https://raw.githubusercontent.com/uniweb/docs/main/{section}/{page}.md`

Examples:
- Content structure details: `reference/content-structure.md`
- Component metadata (meta.js): `reference/component-metadata.md`
- Kit hooks and components: `reference/kit-reference.md`
- Theming tokens: `reference/site-theming.md`
- Data fetching patterns: `reference/data-fetching.md`
